{"version":3,"sources":["../src/libs/filter-mdx-pages.ts"],"names":["FilterMdxPages","pages","sortBy","sortOrder","mdxPages","item","child","sortMdxPages","FilterPageType","type","results","a","b","dateA","dateB","nameA","nameB","paginateMdxPages","limit","currentPage","totalPages","offset","filter_mdx_pages_default"],"mappings":"AAcO,SAASA,EAAeC,EAAsBC,EAAiB,OAAQC,EAAuB,aAAyB,CAC1H,IAAMC,EAAsB,CAAC,EAE7B,OAAAH,EAAM,QAASI,GAAS,CAEfA,EAAK,OAAS,WAAeA,EAAK,aAAa,aAAgBA,EAAK,aAAa,OAAS,OAC3FD,EAAS,KAAKC,CAAI,EACXA,EAAK,OAAS,UAAYA,EAAK,UACtCA,EAAK,SAAS,QAASC,GAAU,CACzBA,EAAM,OAAS,WAAaA,EAAM,aAAa,OAAS,QAAYA,EAAM,aAAa,aACvFF,EAAS,KAAKE,CAAK,CAE3B,CAAC,CAET,CAAC,EAEGJ,GACAK,EAAaH,EAAUF,EAAQC,CAAS,EAGrCC,CACX,CAQO,SAASI,EAAeP,EAAsBQ,EAAe,OAAmB,CACnF,IAAMC,EAAqB,CAAC,EAE5B,OAAAT,EAAM,QAASI,GAAS,CAChBA,EAAK,OAAS,WAAaA,EAAK,aAAa,OAASI,EACtDC,EAAQ,KAAKL,CAAI,EACVA,EAAK,OAAS,UAAYA,EAAK,UACtCA,EAAK,SAAS,QAASC,GAAU,CACzBA,EAAM,OAAS,WAAaA,EAAM,aAAa,OAAS,QAAYA,EAAM,aAAa,aACvFI,EAAQ,KAAKJ,CAAK,CAE1B,CAAC,CAGT,CAAC,EAEMI,CAEX,CAEO,SAASH,EAAaH,EAAqBF,EAAgBC,EAA4B,CAC1FC,EAAS,KAAK,CAACO,EAAGC,IAAM,CACpB,OAAQV,EAAQ,CACZ,IAAK,OACD,IAAMW,EAAQ,IAAI,KAAKF,EAAE,aAAa,IAAI,EACpCG,EAAQ,IAAI,KAAKF,EAAE,aAAa,IAAI,EAC1C,OAAOT,IAAc,YAAcU,EAAM,QAAQ,EAAIC,EAAM,QAAQ,EAAIA,EAAM,QAAQ,EAAID,EAAM,QAAQ,EAC3G,IAAK,OACD,IAAME,EAAQJ,EAAE,KAAK,YAAY,EAC3BK,EAAQJ,EAAE,KAAK,YAAY,EACjC,OAAOT,IAAc,YAAcY,EAAM,cAAcC,CAAK,EAAIA,EAAM,cAAcD,CAAK,EAC7F,QACI,MAAO,EACf,CACJ,CAAC,CACL,CAEO,SAASE,EAAiBb,EAAqBc,EAAeC,EAMnE,CACE,IAAMC,EAAa,KAAK,KAAKhB,EAAS,OAASc,CAAK,EAC9CG,GAAUF,EAAc,GAAKD,EAC7BjB,EAAQG,EAAS,MAAMiB,EAAQA,EAASH,CAAK,EAEnD,MAAO,CACH,WAAAE,EACA,YAAAD,EACA,YAAaA,EAAcC,EAC3B,YAAaD,EAAc,EAC3B,MAAAlB,CACJ,CACJ,CAEA,IAAOqB,EAAQtB","sourcesContent":["// import { MdxPage } from './filter-mdx-pages';\nimport { PageMapItem, MdxFile } from \"nextra\";\n\nexport type SortBy = \"date\" | \"name\";\n\nexport type SortOrder = \"ascending\" | \"descending\";\n\n/**\n * Filters an array of pages and returns only the MDX pages.\n * @param pages An array of pages.\n * @param sortBy The field to sort by.\n * @param sortOrder The sort order.\n * @returns An array of MDX pages.\n */\nexport function FilterMdxPages(pages: PageMapItem[], sortBy: SortBy = 'date', sortOrder: SortOrder = \"descending\"): MdxFile[] {\n    const mdxPages: MdxFile[] = [];\n\n    pages.forEach((item) => {\n\n        if ((item.kind === \"MdxPage\" && !!item.frontMatter?.description) && item.frontMatter?.type !== 'page') {\n            mdxPages.push(item);\n        } else if (item.kind === \"Folder\" && item.children) {\n            item.children.forEach((child) => {\n                if (child.kind === \"MdxPage\" && child.frontMatter?.type !== 'page' && !!child.frontMatter?.description) {\n                    mdxPages.push(child);\n                }\n            });\n        }\n    });\n\n    if (sortBy) {\n        sortMdxPages(mdxPages, sortBy, sortOrder);\n    }\n\n    return mdxPages;\n}\n\n/**\n * Filter a list of pages and return only the pages with the specified frontMatter type\n * @param pages array of pages\n * @param type the type defined in the frontmatter\n * @returns \n */\nexport function FilterPageType(pages: PageMapItem[], type: string = 'page'): MdxFile[] {\n    const results: MdxFile[] = [];\n\n    pages.forEach((item) => {\n        if (item.kind === \"MdxPage\" && item.frontMatter?.type === type) {\n            results.push(item);\n        } else if (item.kind === 'Folder' && item.children) {\n            item.children.forEach((child) => {\n                if (child.kind === \"MdxPage\" && child.frontMatter?.type === 'page' && !!child.frontMatter?.description) {\n                    results.push(child);\n                }\n            });\n        }\n\n    });\n\n    return results;\n\n}\n\nexport function sortMdxPages(mdxPages: MdxFile[], sortBy: SortBy, sortOrder: SortOrder): void {\n    mdxPages.sort((a, b) => {\n        switch (sortBy) {\n            case \"date\":\n                const dateA = new Date(a.frontMatter?.date);\n                const dateB = new Date(b.frontMatter?.date);\n                return sortOrder === \"ascending\" ? dateA.getTime() - dateB.getTime() : dateB.getTime() - dateA.getTime();\n            case \"name\":\n                const nameA = a.name.toLowerCase();\n                const nameB = b.name.toLowerCase();\n                return sortOrder === \"ascending\" ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);\n            default:\n                return 0;\n        }\n    });\n}\n\nexport function paginateMdxPages(mdxPages: MdxFile[], limit: number, currentPage: number): {\n    totalPages: number,\n    currentPage: number,\n    hasNextPage: boolean,\n    hasPrevPage: boolean,\n    pages: MdxFile[]\n} {\n    const totalPages = Math.ceil(mdxPages.length / limit);\n    const offset = (currentPage - 1) * limit;\n    const pages = mdxPages.slice(offset, offset + limit);\n\n    return {\n        totalPages,\n        currentPage,\n        hasNextPage: currentPage < totalPages,\n        hasPrevPage: currentPage > 1,\n        pages,\n    };\n}\n\nexport default FilterMdxPages;\n// const mdxPages = filterMdxPages(pages);"]}